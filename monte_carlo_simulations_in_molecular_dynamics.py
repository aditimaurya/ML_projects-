# -*- coding: utf-8 -*-
"""Monte_Carlo_Simulations_in_Molecular_Dynamics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_GFiYhOj1x1rdLULuA3NheS8dsxunetg
"""

import pandas as pd
import numpy as np
import math
import random
import matplotlib.pyplot as plt
from random import seed
from random import randint
from random import random
from random import uniform
from datetime import datetime
from mpl_toolkits import mplot3d

#int_state = pd.read_csv("prac.csv", sep = "\t")
int_state = pd.read_csv("start_state.csv")

int_state

#50 Ar molecules are picked
#sigma = 3.4 Angs.
#epsilon = 1 kJ/mol.
#cell dimension (L) = 26 Angs.
#Cut-off radius(r_c) = 10 Angs.

def gen_random_number(start, end):
    seed(datetime.now())
    value = randint(start,end-1)
    return value

#12 - 6 lennard jones
def lennard_jones(r, eps = 1, sig = 3.4, m = 12, n = 6):      #m =12, n =6
    if r>=10:     #according to conditions
        return 0
    
    a1 = sig/r
    a = 4*eps*(pow(a1,m) - pow(a1,n))
    return a

def minimum_image_convention(dis):
    L = 26
    if dis > L/2:
        dis = dis - L
    elif dis <= -L/2:
        dis = dis + L
    
    return dis

#net potential energy of the system
def calculate_potential_energy(pos, N):
    v_net = 0.0    #stores the potential energy
    
    for i in range(N-1):
        x1 = pos.iloc[i][0]
        y1 = pos.iloc[i][1]
        z1 = pos.iloc[i][2]
        for j in range(i+1, N):
            x2 = pos.iloc[j][0]
            y2 = pos.iloc[j][1]
            z2 = pos.iloc[j][2]
            
            #applying minimum image convention
            dx = x2 - x1
            dy = y2 - y1
            dz = z2 - z1
            
            dx = minimum_image_convention(dx)
            dy = minimum_image_convention(dy)
            dz = minimum_image_convention(dz)
            
            r_ij = math.sqrt(dx**2 + dy**2 + dz**2)
            v_net += lennard_jones(r_ij)
    return v_net

#interaction energy with respect to the selected particle
def interaction_energy(pos, N, particle):
    i_net = 0
    x_particle = pos.iloc[particle][0]
    y_particle = pos.iloc[particle][1]
    z_particle = pos.iloc[particle][2]
    for i in range(N):
        if i == particle:
            continue
        x1 = pos.iloc[i][0]
        y1 = pos.iloc[i][1]
        z1 = pos.iloc[i][2]
        
        #applying minimum image convention
        dx = x1 - x_particle
        dy = y1 - y_particle
        dz = z1 - z_particle
            
        dx = minimum_image_convention(dx)
        dy = minimum_image_convention(dy)
        dz = minimum_image_convention(dz)
        
        r_i_particle = math.sqrt(dx**2 + dy**2 + dz**2)
        i_net += lennard_jones(r_i_particle)
    return i_net

def pbc_on_one_particle(x, y, z):
        L = 26                   #L is given in question
        applied_pbc = False
        if x>L/2: 
            x = x - L
            applied_pbc = True
        elif x<= -L/2:
            x = x + L
            applied_pbc = True
        
        if y > L/2: 
            y = y - L
            applied_pbc = True
        elif y<= -L/2: 
            y = y + L
            applied_pbc = True
            
        if z > L/2: 
            z = z - L
            applied_pbc = True
        elif z<= -L/2: 
            z = z + L
            applied_pbc = True
        
        return x,y,z, applied_pbc

def pbc(df, n):
    ans = 0      #total number of pbc appplied in 1 iteration
    for i in range(n):
        x = df.iloc[i][0]
        y = df.iloc[i][1]
        z = df.iloc[i][2]
    
        
        x, y, z, applied_pbc = pbc_on_one_particle(x ,y, z)
        df.iloc[i][0] = x
        df.iloc[i][1] = y
        df.iloc[i][2] = z
        if(applied_pbc == True):
            ans += 1
    
    return df, ans

def distance_in_3D(ith, jth):
    x1 = ith[0]
    y1 = ith[1]
    z1 = ith[2]
    x2 = jth[0]
    y2 = jth[1]
    z2 = jth[2]
    return math.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)

def metropolis_monte_carlo(start_state, T, K = 1.380649*math.pow(10,-25)):
    #start_state is a dataframe
    #T is the temperature
    #K is Boltzman constant 
    N = len(start_state)
    tally = 1
    #now we randomly select a particle in 0-N
    particle = gen_random_number(0, N)
    #print(particle)
    #calculating its interaction energy
    i_net_old = interaction_energy(start_state, N, particle)
    
    #giving the particle a small random displacement 
    seed(datetime.now())
    del_dis_x = uniform(-18,18)
    jx = start_state.iloc[particle][0] 
    start_state.iloc[particle][0] += del_dis_x
    
    seed(datetime.now())
    del_dis_y = uniform(-18,18)
    jy = start_state.iloc[particle][1] 
    start_state.iloc[particle][1] += del_dis_y
    
    seed(datetime.now())
    del_dis_z = uniform(-18,18)
    jz = start_state.iloc[particle][2] 
    start_state.iloc[particle][2] += del_dis_z
    
    #calculating new interaction energy
    i_net_new = interaction_energy(start_state, N, particle)
    
    del_interation_energy = i_net_new - i_net_old
    
    #chceking if the displacement is accepted or not
    if del_interation_energy>=0:
        check_val = math.exp(-del_interation_energy/(K*T))
        seed(datetime.now())
        check_against = random()
        if(check_val < check_against):
            tally = -1
            start_state.iloc[particle][0] = jx
            start_state.iloc[particle][1] = jy
            start_state.iloc[particle][2] = jz
    return start_state, tally

def number_of_iter(start_state, max_iter, max_allowed_tal, T):
    tal = 0
    max_tal = 0
    new_state = start_state.copy()
    fig = plt.figure(figsize = (10,7))
    ax = plt.axes(projection ="3d")
    ax.scatter3D(new_state['x'], new_state['y'], new_state['z'], color = "green")
    plt.show()
    print("Initial potential enerygy of random system: ",calculate_potential_energy(new_state, len(new_state)), "   kJ/mol")
    for i in range(max_iter):
        #performing one step of the algorithm
        new_state, tally = metropolis_monte_carlo(new_state, T)
        if tally == -1:
            tal+=1
        else:
            tal = 0
        if tal>max_tal:
            max_tal = tal
        if max_tal>max_allowed_tal:
            break
        #print(calculate_potential_energy(new_state, len(new_state)))
        
        #performing some visualizations
        '''fig = plt.figure(figsize = (10,7))
        ax = plt.axes(projection ="3d")
        ax.scatter3D(new_state['x'], new_state['y'], new_state['z'], color = "green")
        plt.show()'''
    fig = plt.figure(figsize = (10,7))
    ax = plt.axes(projection ="3d")
    ax.scatter3D(new_state['x'], new_state['y'], new_state['z'], color = "green")
    plt.show()
    print(max_tal)
    print("Calculated potential energy is: ",calculate_potential_energy(new_state, len(new_state)), "   kJ/mol")

number_of_iter(int_state, 1000, 1000, 300)























































